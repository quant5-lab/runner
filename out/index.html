<!doctype html>
<html>
  <head>
    <title>Financial Chart Visualization</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.development.js"></script>
    <script type="module">
      import { adaptLineSeriesData } from './lineSeriesAdapter.js';
      window.adaptLineSeriesData = adaptLineSeriesData;
    </script>
    <style>
      body {
        background-color: #0f172a;
        margin: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        color: #cbd5e1;
        font-family: 'Segoe UI', system-ui, sans-serif;
      }

      #container {
        width: 100%;
        max-width: 90vw;
        margin: 0 auto;
        padding: 1.5rem;
        background-color: #1e293b;
        border: 1px solid #334155;
        border-radius: 8px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2);
        min-height: auto;
        transition: all 0.3s ease;
      }

      h1 {
        color: #5eead4;
        font-size: 2.5rem;
        margin-bottom: 2rem;
        text-align: center;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        background: linear-gradient(45deg, #5eead4, #2dd4bf);
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
      }

      .info {
        background-color: #1a2035;
        border: 1px solid #2d3748;
        border-radius: 6px;
        padding: 1rem;
        margin-bottom: 1rem;
        color: #cbd5e1;
      }

      .chart-container {
        background-color: #1e293b;
        border: 1px solid #334155;
        border-radius: 6px;
        overflow: hidden;
        margin-bottom: 2rem;
      }

      #main-chart {
        position: relative;
        z-index: 1;
      }

      #indicator-chart {
        position: relative;
        z-index: 1;
      }

      .refresh-btn {
        background-color: #2563eb;
        color: white;
        border: none;
        padding: 0.75rem 1.5rem;
        border-radius: 6px;
        font-size: 1rem;
        cursor: pointer;
        margin-bottom: 1rem;
        transition: background-color 0.2s;
      }

      .refresh-btn:hover {
        background-color: #1d4ed8;
      }

      .timestamp {
        color: #6b7280;
        font-size: 0.875rem;
        text-align: center;
        margin-top: 1rem;
      }
    </style>
  </head>

  <body>
    <div id="container">
      <h1 id="chart-title">Financial Chart</h1>

      <div class="info" id="strategy-info">
        <strong>Symbol:</strong> <span id="symbol-display">Loading...</span><br />
        <strong>Timeframe:</strong> <span id="timeframe-display">Loading...</span><br />
        <strong>Strategy:</strong> <span id="strategy-display">Loading...</span>
      </div>

      <button class="refresh-btn" onclick="loadChartData()">Refresh Data</button>

      <div class="chart-container">
        <div id="main-chart"></div>
      </div>

      <div class="timestamp" id="timestamp"></div>
    </div>

    <script>
      /* PaneManager: Manages chart pane lifecycle */
      class PaneManager {
        constructor(chartOptions) {
          this.chartOptions = chartOptions;
          this.mainPane = null;
          this.dynamicPanes = new Map();
        }

        createMainPane(container, config) {
          this.mainPane = {
            container,
            chart: LightweightCharts.createChart(container, {
              ...this.chartOptions,
              height: config.height,
              width: container.clientWidth,
            }),
          };
          return this.mainPane;
        }

        createDynamicPane(paneName, config) {
          const containerDiv = document.createElement('div');
          containerDiv.id = `${paneName}-chart`;
          containerDiv.style.position = 'relative';
          containerDiv.style.zIndex = '1';

          const chartContainerDiv = document.querySelector('.chart-container');
          chartContainerDiv.appendChild(containerDiv);

          const chart = LightweightCharts.createChart(containerDiv, {
            ...this.chartOptions,
            height: config.height,
            width: containerDiv.clientWidth,
          });

          this.dynamicPanes.set(paneName, { container: containerDiv, chart });
          return { container: containerDiv, chart };
        }

        getPane(paneName) {
          return paneName === 'main' ? this.mainPane : this.dynamicPanes.get(paneName);
        }

        getAllCharts() {
          const charts = [this.mainPane.chart];
          this.dynamicPanes.forEach(({ chart }) => charts.push(chart));
          return charts;
        }

        getAllContainers() {
          const containers = [this.mainPane.container];
          this.dynamicPanes.forEach(({ container }) => containers.push(container));
          return containers;
        }

        synchronizeTimeScales() {
          const charts = this.getAllCharts();
          let isUpdating = false;

          charts.forEach((sourceChart, sourceIndex) => {
            sourceChart.timeScale().subscribeVisibleLogicalRangeChange((logicalRange) => {
              if (isUpdating || !logicalRange) return;

              isUpdating = true;
              requestAnimationFrame(() => {
                charts.forEach((targetChart, targetIndex) => {
                  if (sourceIndex !== targetIndex) {
                    try {
                      targetChart.timeScale().setVisibleLogicalRange(logicalRange);
                    } catch (error) {
                      console.warn('Failed to sync logical range:', error);
                    }
                  }
                });
                isUpdating = false;
              });
            });
          });
        }
      }

      /* Global chart variables */
      let mainChart,
        indicatorChart,
        seriesMap = {};
      let CONFIG = null;
      let paneManager = null;

      /* SeriesRouter: Routes series to correct pane */
      class SeriesRouter {
        constructor(paneManager, seriesMap) {
          this.paneManager = paneManager;
          this.seriesMap = seriesMap;
        }

        routeSeries(seriesKey, seriesConfig, chartManager) {
          const paneName = seriesConfig.chart || 'indicator';
          const pane = this.paneManager.getPane(paneName);

          if (!pane) {
            console.warn(`Pane '${paneName}' not found for series '${seriesKey}'`);
            return null;
          }

          const seriesType = seriesConfig.style || 'line';
          let series;

          if (seriesType === 'histogram') {
            series = chartManager.addHistogramSeries(pane.chart, seriesConfig);
          } else {
            series = chartManager.addLineSeries(pane.chart, seriesConfig);
          }

          this.seriesMap[seriesKey] = series;
          return series;
        }

        rerouteSeries(seriesKey, newPaneName, seriesConfig, chartManager) {
          const oldSeries = this.seriesMap[seriesKey];
          if (!oldSeries) return null;

          const oldPaneName = seriesConfig.chart;
          const oldPane = this.paneManager.getPane(oldPaneName);

          if (oldPane && oldPane.chart) {
            oldPane.chart.removeSeries(oldSeries);
          }

          seriesConfig.chart = newPaneName;
          return this.routeSeries(seriesKey, seriesConfig, chartManager);
        }
      }

      /* Configuration loader */
      const ConfigLoader = {
        async loadConfig(url = 'chart-config.json') {
          const response = await fetch(url);
          return await response.json();
        },
      };

      /* Chart configuration */
      const chartOptions = {
        layout: {
          background: { color: '#1e1e3c' },
          textColor: '#DDD',
        },
        grid: {
          vertLines: { color: '#2B2B43' },
          horzLines: { color: '#2B2B43' },
        },
        rightPriceScale: {
          borderColor: '#2B2B43',
        },
        timeScale: {
          borderColor: '#2B2B43',
        },
        crosshair: {
          mode: LightweightCharts.CrosshairMode.Normal,
          vertLine: {
            visible: true,
          },
          horzLine: {
            visible: true,
            labelVisible: true,
          },
        },
      };

      /* UI utilities */
      const UIManager = {
        updateDisplay(config) {
          if (config.ui) {
            document.getElementById('chart-title').textContent =
              config.ui.title || 'Financial Chart';
            document.getElementById('symbol-display').textContent = config.ui.symbol || 'Unknown';
            document.getElementById('timeframe-display').textContent =
              config.ui.timeframe || 'Unknown';
            document.getElementById('strategy-display').textContent =
              config.ui.strategy || 'Unknown';
          }
        },
      };

      async function initializeCharts() {
        CONFIG = await ConfigLoader.loadConfig();

        /* Initialize PaneManager */
        paneManager = new PaneManager(chartOptions);

        /* Create main pane (fixed) */
        const mainContainer = document.getElementById('main-chart');
        paneManager.createMainPane(mainContainer, CONFIG.chartLayout.main);
        mainChart = paneManager.mainPane.chart;

        /* Create dynamic panes from chartLayout config */
        Object.entries(CONFIG.chartLayout).forEach(([paneName, paneConfig]) => {
          if (paneName !== 'main') {
            const pane = paneManager.createDynamicPane(paneName, paneConfig);
            if (paneName === 'indicator') {
              indicatorChart = pane.chart;
            }
          }
        });

        /* Initialize SeriesRouter */
        const seriesRouter = new SeriesRouter(paneManager, seriesMap);

        /* Add candlestick series to main pane */
        seriesMap.candlestick = ChartManager.addCandlestickSeries(
          mainChart,
          CONFIG.seriesConfig.candlestick,
        );

        /* Route all series to correct panes */
        Object.entries(CONFIG.seriesConfig.series).forEach(([key, seriesConfig]) => {
          seriesRouter.routeSeries(key, seriesConfig, ChartManager);
        });

        /* Window resize handler */
        window.addEventListener('resize', () => {
          const containers = paneManager.getAllContainers();
          const charts = paneManager.getAllCharts();
          const width = containers[0].clientWidth;
          charts.forEach((chart) => chart.applyOptions({ width }));
        });

        /* Initialize time scale sync */
        setTimeout(() => {
          paneManager.synchronizeTimeScales();
        }, 50);
      }

      /* Data transformation utilities */
      const DataTransformer = {
        validateCandlestick(candle) {
          return (
            candle &&
            typeof candle.time === 'number' &&
            typeof candle.open === 'number' &&
            !isNaN(candle.open) &&
            typeof candle.high === 'number' &&
            !isNaN(candle.high) &&
            typeof candle.low === 'number' &&
            !isNaN(candle.low) &&
            typeof candle.close === 'number' &&
            !isNaN(candle.close) &&
            candle.open > 0 &&
            candle.high > 0 &&
            candle.low > 0 &&
            candle.close > 0 &&
            candle.high >= candle.low &&
            candle.high >= candle.open &&
            candle.high >= candle.close &&
            candle.low <= candle.open &&
            candle.low <= candle.close
          );
        },

        extractCandlestickData(candle) {
          return {
            time: candle.time,
            open: candle.open,
            high: candle.high,
            low: candle.low,
            close: candle.close,
          };
        },

        processPlotData(plotData, plotTitle) {
          /* Uses LineSeries Adapter (Adapter Pattern) */
          return window.adaptLineSeriesData(plotData);
        },

        processCandlestickArray(candlestickArray) {
          return candlestickArray
            .sort((a, b) => a.time - b.time)
            .filter(this.validateCandlestick)
            .map(this.extractCandlestickData);
        },
      };

      /* Chart management utilities */
      const ChartManager = {
        createChart(container, config) {
          return LightweightCharts.createChart(container, {
            ...chartOptions,
            height: config.height,
            width: container.clientWidth,
          });
        },

        addCandlestickSeries(chart, config) {
          return chart.addCandlestickSeries(config);
        },

        addLineSeries(chart, config) {
          return chart.addLineSeries(config);
        },

        addHistogramSeries(chart, config) {
          return chart.addHistogramSeries(config);
        },

        fitContent(charts) {
          charts.forEach((chart) => chart.timeScale().fitContent());
        },

        handleResize(charts, containers) {
          const width = containers[0].clientWidth;
          charts.forEach((chart) => chart.applyOptions({ width }));
        },

        synchronizeTimeScales(charts) {
          let isUpdating = false;

          charts.forEach((sourceChart, sourceIndex) => {
            sourceChart.timeScale().subscribeVisibleLogicalRangeChange((logicalRange) => {
              if (isUpdating || !logicalRange) return;

              isUpdating = true;
              requestAnimationFrame(() => {
                charts.forEach((targetChart, targetIndex) => {
                  if (sourceIndex !== targetIndex) {
                    try {
                      targetChart.timeScale().setVisibleLogicalRange(logicalRange);
                    } catch (error) {
                      console.warn('Failed to sync logical range:', error);
                    }
                  }
                });
                isUpdating = false;
              });
            });
          });
        },
      };

      /* Data loading and processing */
      const DataLoader = {
        async fetchChartData(config) {
          const response = await fetch(config.dataSource.url + '?' + Date.now());
          return await response.json();
        },

        loadCandlestickData(data, series, config) {
          const rawData = this.getNestedProperty(data, config.dataSource.candlestickPath);
          if (!rawData || !Array.isArray(rawData)) return;

          const processedData = DataTransformer.processCandlestickArray(rawData);
          if (processedData.length > 0) {
            series.setData(processedData);
          }
        },

        loadPlotData(data, config, seriesRouter) {
          const plots = this.getNestedProperty(data, config.dataSource.plotsPath);
          if (!plots) return;

          Object.entries(config.seriesConfig.series).forEach(([key, seriesConfig]) => {
            const plotData = plots[key]?.data;
            const series = seriesMap[key];

            if (plotData && series) {
              /* Check first point for pane property */
              const firstPoint = Array.isArray(plotData) ? plotData[0] : null;
              const dataPane = firstPoint?.options?.pane || firstPoint?.pane;
              
              /* If pane differs from config, reroute series to correct pane */
              if (dataPane && dataPane !== seriesConfig.chart) {
                seriesRouter.rerouteSeries(key, dataPane, seriesConfig, ChartManager);
              }
              
              /* Process and set data */
              const processedData = DataTransformer.processPlotData(plotData);
              if (processedData.length > 0) {
                seriesMap[key].setData(processedData);
              }
            }
          });
        },

        updateTimestamp(data, config, elementId = 'timestamp') {
          const timestamp = this.getNestedProperty(data, config.dataSource.timestampPath);
          if (timestamp) {
            document.getElementById(elementId).textContent =
              'Last updated: ' + new Date(timestamp).toLocaleString();
          }
        },

        getNestedProperty(obj, path) {
          return path.split('.').reduce((current, key) => current?.[key], obj);
        },
      };

      async function loadChartData() {
        try {
          const data = await DataLoader.fetchChartData(CONFIG);
          const seriesRouter = new SeriesRouter(paneManager, seriesMap);

          DataLoader.loadCandlestickData(data, seriesMap.candlestick, CONFIG);
          DataLoader.loadPlotData(data, CONFIG, seriesRouter);

          const charts = paneManager.getAllCharts();
          ChartManager.fitContent(charts);
          DataLoader.updateTimestamp(data, CONFIG);
          UIManager.updateDisplay(CONFIG);

          /* Ensure sync is active after data load */
          setTimeout(() => {
            paneManager.synchronizeTimeScales();
          }, 50);
        } catch (error) {
          console.error('Error loading chart data:', error);
        }
      }

      // Initialize everything when DOM is loaded
      document.addEventListener('DOMContentLoaded', async () => {
        await initializeCharts();
        await loadChartData();
      });
    </script>
  </body>
</html>
