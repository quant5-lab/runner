<!doctype html>
<html>
  <head>
    <title>Financial Chart Visualization</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.development.js"></script>
    <script type="module">
      import { adaptLineSeriesData } from './lineSeriesAdapter.js';
      window.adaptLineSeriesData = adaptLineSeriesData;
    </script>
    <style>
      body {
        background-color: #0f172a;
        margin: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        color: #cbd5e1;
        font-family: 'Segoe UI', system-ui, sans-serif;
      }

      #container {
        width: 100%;
        max-width: 90vw;
        margin: 0 auto;
        padding: 1.5rem;
        background-color: #1e293b;
        border: 1px solid #334155;
        border-radius: 8px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2);
        min-height: auto;
        transition: all 0.3s ease;
      }

      h1 {
        color: #5eead4;
        font-size: 2.5rem;
        margin-bottom: 2rem;
        text-align: center;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        background: linear-gradient(45deg, #5eead4, #2dd4bf);
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
      }

      .info {
        background-color: #1a2035;
        border: 1px solid #2d3748;
        border-radius: 6px;
        padding: 1rem;
        margin-bottom: 1rem;
        color: #cbd5e1;
      }

      .chart-container {
        background-color: #1e293b;
        border: 1px solid #334155;
        border-radius: 6px;
        overflow: hidden;
        margin-bottom: 2rem;
      }

      #main-chart {
        position: relative;
        z-index: 1;
      }

      #indicator-chart {
        position: relative;
        z-index: 1;
      }

      .refresh-btn {
        background-color: #2563eb;
        color: white;
        border: none;
        padding: 0.75rem 1.5rem;
        border-radius: 6px;
        font-size: 1rem;
        cursor: pointer;
        margin-bottom: 1rem;
        transition: background-color 0.2s;
      }

      .refresh-btn:hover {
        background-color: #1d4ed8;
      }

      .timestamp {
        color: #6b7280;
        font-size: 0.875rem;
        text-align: center;
        margin-top: 1rem;
      }
    </style>
  </head>

  <body>
    <div id="container">
      <h1 id="chart-title">Financial Chart</h1>

      <div class="info" id="strategy-info">
        <strong>Symbol:</strong> <span id="symbol-display">Loading...</span><br />
        <strong>Timeframe:</strong> <span id="timeframe-display">Loading...</span><br />
        <strong>Strategy:</strong> <span id="strategy-display">Loading...</span>
      </div>

      <button class="refresh-btn" onclick="loadChartData()">Refresh Data</button>

      <div class="chart-container">
        <div id="main-chart"></div>
        <div id="indicator-chart"></div>
      </div>

      <div class="timestamp" id="timestamp"></div>
    </div>

    <script>
      /* Global chart variables */
      let mainChart,
        indicatorChart,
        seriesMap = {};
      let CONFIG = null;

      /* Configuration loader */
      const ConfigLoader = {
        async loadConfig(url = 'chart-config.json') {
          const response = await fetch(url);
          return await response.json();
        },
      };

      /* Chart configuration */
      const chartOptions = {
        layout: {
          background: { color: '#1e1e3c' },
          textColor: '#DDD',
        },
        grid: {
          vertLines: { color: '#2B2B43' },
          horzLines: { color: '#2B2B43' },
        },
        rightPriceScale: {
          borderColor: '#2B2B43',
        },
        timeScale: {
          borderColor: '#2B2B43',
        },
        crosshair: {
          mode: LightweightCharts.CrosshairMode.Normal,
          vertLine: {
            visible: true,
          },
          horzLine: {
            visible: true,
            labelVisible: true,
          },
        },
      };

      /* UI utilities */
      const UIManager = {
        updateDisplay(config) {
          if (config.ui) {
            document.getElementById('chart-title').textContent =
              config.ui.title || 'Financial Chart';
            document.getElementById('symbol-display').textContent = config.ui.symbol || 'Unknown';
            document.getElementById('timeframe-display').textContent =
              config.ui.timeframe || 'Unknown';
            document.getElementById('strategy-display').textContent =
              config.ui.strategy || 'Unknown';
          }
        },
      };

      async function initializeCharts() {
        CONFIG = await ConfigLoader.loadConfig();

        const mainContainer = document.getElementById('main-chart');
        const indicatorContainer = document.getElementById('indicator-chart');

        mainChart = ChartManager.createChart(mainContainer, CONFIG.chartLayout.main);
        indicatorChart = ChartManager.createChart(indicatorContainer, CONFIG.chartLayout.indicator);

        seriesMap.candlestick = ChartManager.addCandlestickSeries(
          mainChart,
          CONFIG.seriesConfig.candlestick,
        );

        Object.entries(CONFIG.seriesConfig.series).forEach(([key, seriesConfig]) => {
          const targetChart = seriesConfig.chart === 'main' ? mainChart : indicatorChart;
          const seriesType = seriesConfig.style || 'line';
          if (seriesType === 'histogram') {
            seriesMap[key] = ChartManager.addHistogramSeries(targetChart, seriesConfig);
          } else {
            seriesMap[key] = ChartManager.addLineSeries(targetChart, seriesConfig);
          }
        });

        window.addEventListener('resize', () => {
          ChartManager.handleResize([mainChart, indicatorChart], [mainContainer]);
        });

        /* Initialize sync after charts are fully loaded */
        setTimeout(() => {
          ChartManager.synchronizeTimeScales([mainChart, indicatorChart]);
        }, 50);
      }

      /* Data transformation utilities */
      const DataTransformer = {
        validateCandlestick(candle) {
          return (
            candle &&
            typeof candle.time === 'number' &&
            typeof candle.open === 'number' &&
            !isNaN(candle.open) &&
            typeof candle.high === 'number' &&
            !isNaN(candle.high) &&
            typeof candle.low === 'number' &&
            !isNaN(candle.low) &&
            typeof candle.close === 'number' &&
            !isNaN(candle.close) &&
            candle.open > 0 &&
            candle.high > 0 &&
            candle.low > 0 &&
            candle.close > 0 &&
            candle.high >= candle.low &&
            candle.high >= candle.open &&
            candle.high >= candle.close &&
            candle.low <= candle.open &&
            candle.low <= candle.close
          );
        },

        extractCandlestickData(candle) {
          return {
            time: candle.time,
            open: candle.open,
            high: candle.high,
            low: candle.low,
            close: candle.close,
          };
        },

        processPlotData(plotData, plotTitle) {
          /* Uses LineSeries Adapter (Adapter Pattern) */
          return window.adaptLineSeriesData(plotData);
        },

        processCandlestickArray(candlestickArray) {
          return candlestickArray
            .sort((a, b) => a.time - b.time)
            .filter(this.validateCandlestick)
            .map(this.extractCandlestickData);
        },
      };

      /* Chart management utilities */
      const ChartManager = {
        createChart(container, config) {
          return LightweightCharts.createChart(container, {
            ...chartOptions,
            height: config.height,
            width: container.clientWidth,
          });
        },

        addCandlestickSeries(chart, config) {
          return chart.addCandlestickSeries(config);
        },

        addLineSeries(chart, config) {
          return chart.addLineSeries(config);
        },

        addHistogramSeries(chart, config) {
          return chart.addHistogramSeries(config);
        },

        fitContent(charts) {
          charts.forEach((chart) => chart.timeScale().fitContent());
        },

        handleResize(charts, containers) {
          const width = containers[0].clientWidth;
          charts.forEach((chart) => chart.applyOptions({ width }));
        },

        synchronizeTimeScales(charts) {
          let isUpdating = false;

          charts.forEach((sourceChart, sourceIndex) => {
            sourceChart.timeScale().subscribeVisibleLogicalRangeChange((logicalRange) => {
              if (isUpdating || !logicalRange) return;

              isUpdating = true;
              requestAnimationFrame(() => {
                charts.forEach((targetChart, targetIndex) => {
                  if (sourceIndex !== targetIndex) {
                    try {
                      targetChart.timeScale().setVisibleLogicalRange(logicalRange);
                    } catch (error) {
                      console.warn('Failed to sync logical range:', error);
                    }
                  }
                });
                isUpdating = false;
              });
            });
          });
        },
      };

      /* Data loading and processing */
      const DataLoader = {
        async fetchChartData(config) {
          const response = await fetch(config.dataSource.url + '?' + Date.now());
          return await response.json();
        },

        loadCandlestickData(data, series, config) {
          const rawData = this.getNestedProperty(data, config.dataSource.candlestickPath);
          if (!rawData || !Array.isArray(rawData)) return;

          const processedData = DataTransformer.processCandlestickArray(rawData);
          if (processedData.length > 0) {
            series.setData(processedData);
          }
        },

        loadPlotData(data, config) {
          const plots = this.getNestedProperty(data, config.dataSource.plotsPath);
          if (!plots) return;

          Object.entries(config.seriesConfig.series).forEach(([key, seriesConfig]) => {
            const plotData = this.getNestedProperty(plots, `${key}.data`);
            const series = seriesMap[key];

            if (plotData && series) {
              /* Check first point for pane property */
              const firstPoint = Array.isArray(plotData) ? plotData[0] : null;
              const dataPane = firstPoint?.options?.pane || firstPoint?.pane;
              
              /* If pane differs from config, recreate series on correct chart */
              if (dataPane && dataPane !== seriesConfig.chart) {
                /* Remove old series */
                const oldChart = seriesConfig.chart === 'main' ? mainChart : indicatorChart;
                if (seriesMap[key]) {
                  oldChart.removeSeries(seriesMap[key]);
                }
                
                /* Add series to correct chart */
                const targetChart = dataPane === 'main' ? mainChart : indicatorChart;
                const seriesType = seriesConfig.style || 'line';
                if (seriesType === 'histogram') {
                  seriesMap[key] = ChartManager.addHistogramSeries(targetChart, seriesConfig);
                } else {
                  seriesMap[key] = ChartManager.addLineSeries(targetChart, seriesConfig);
                }
              }
              
              /* Process and set data */
              const processedData = DataTransformer.processPlotData(plotData);
              if (processedData.length > 0) {
                seriesMap[key].setData(processedData);
              }
            }
          });
        },

        updateTimestamp(data, config, elementId = 'timestamp') {
          const timestamp = this.getNestedProperty(data, config.dataSource.timestampPath);
          if (timestamp) {
            document.getElementById(elementId).textContent =
              'Last updated: ' + new Date(timestamp).toLocaleString();
          }
        },

        getNestedProperty(obj, path) {
          return path.split('.').reduce((current, key) => current?.[key], obj);
        },
      };

      async function loadChartData() {
        try {
          const data = await DataLoader.fetchChartData(CONFIG);

          DataLoader.loadCandlestickData(data, seriesMap.candlestick, CONFIG);
          DataLoader.loadPlotData(data, CONFIG);

          ChartManager.fitContent([mainChart, indicatorChart]);
          DataLoader.updateTimestamp(data, CONFIG);
          UIManager.updateDisplay(CONFIG);

          /* Ensure sync is active after data load */
          setTimeout(() => {
            ChartManager.synchronizeTimeScales([mainChart, indicatorChart]);
          }, 50);
        } catch (error) {
          console.error('Error loading chart data:', error);
        }
      }

      // Initialize everything when DOM is loaded
      document.addEventListener('DOMContentLoaded', async () => {
        await initializeCharts();
        await loadChartData();
      });
    </script>
  </body>
</html>
